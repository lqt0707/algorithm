/**
 * 选择排序（Selection Sort）是一种简单的排序算法，其原理是通过重复从未排序的元素中选择最小（或最大）的元素，并将其放置在已排序部分的末尾。

选择排序的工作原理如下：

遍历数组：从数组的第一个元素开始，依次向后遍历每个元素。

寻找最小元素：在当前未排序的元素中，找到最小的元素。

交换位置：将最小的元素与当前未排序部分的第一个元素进行交换，将最小元素放置在已排序部分的末尾。

重复步骤 2 和 3：继续从剩余的未排序元素中选择最小元素，并将其放置在已排序部分的末尾，直到遍历完整个数组。

完成排序：当遍历完数组后，所有元素都已按照升序（或降序）排列。

选择排序的关键点在于每次内层循环都会选择未排序部分的最小（或最大）元素，并将其放置在已排序部分的末尾。通过不断选择最小元素并交换位置，逐步形成有序的子序列，最终完成整个数组的排序。

选择排序的时间复杂度为 O(n^2)，其中 n 是数组的长度。尽管选择排序的时间复杂度较高，但由于其简单直观的实现方式，对于小型数组或部分有序的数组，选择排序仍然是一种可行的排序算法。
 */

export function selectSort(array) {
  // 定义 minIndex，缓存当前区间最小值的索引，注意是索引
  let minIndex;
  // i 是当前排序区间的起点
  for (let i = 0; i < array.length; i++) {
    // 初始化 minIndex 为当前区间第一个元素
    minIndex = i;
    // i、j分别定义当前区间的上下界，i是左边界，j是右边界
    for (let j = i; j < array.length; j++) {
      // 若 j 处的数据项比当前最小值还要小，则更新最小值索引为 j
      if (array[j] < array[minIndex]) {
        minIndex = j;
      }
    }
    // 如果 minIndex 对应元素不是目前的头部元素，则交换两者
    if (minIndex !== i) {
      [array[i], array[minIndex]] = [array[minIndex], array[i]];
    }
  }
  return array;
}

console.log(selectSort([3, 1, 5, 4, 64, 322, 3, 26, 7, 0]));
